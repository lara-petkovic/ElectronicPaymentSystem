{"version":3,"sources":["ng://ngx-websocket/lib/subscribe.ts","ng://ngx-websocket/lib/socket.ts","ng://ngx-websocket/lib/ngx-websocket.service.ts","ng://ngx-websocket/lib/ngx-websocket.component.ts","ng://ngx-websocket/lib/ngx-websocket.module.ts"],"names":["Subscribe","_type","_f","this","type","f","Socket","url","_this","websocket","WebSocket","e","console","error","_state","_subscribes","addEventListener","subscribeLoop","_receiveData","warn","prototype","then","push","message","catch","finally","send","close","init","i","len","length","sub","_passingData","data","NgxWebsocketService","sockets","Map","open","checkExistence","socket","set","forEach","key","value","Injectable","args","providedIn","NgxWebsocketComponent","websocketService","Component","selector","template","styles","NgxWebsocketModule","NgModule","imports","declarations","exports"],"mappings":"wQAAA,IAAAA,EAGI,SAAYC,EAAeC,GACvBC,KAAKC,KAAOH,EACZE,KAAKE,EAAIH,GCEjBI,EAAA,WAWI,SAAAA,EAAoBC,GAApB,IAAAC,EAAAL,KAAoBA,KAAAI,IAAAA,EAChB,IACIJ,KAAKM,UAAY,IAAIC,UAAUH,GACjC,MAAMI,GACHC,QAAQC,MAAMF,GAEnBR,KAAKW,OAAS,SACdX,KAAKY,YAAc,GAEnBZ,KAAKM,UAAUO,iBAAiB,OAAQ,SAACL,GAErCH,EAAKS,eAAc,KAIvBd,KAAKM,UAAUO,iBAAiB,QAAS,SAACL,GACtCC,QAAQC,MAAM,uBAelBV,KAAKM,UAAUO,iBAAiB,UAAW,SAACL,GACxCH,EAAKU,aAAeP,EAEpBH,EAAKS,eAAc,KAIvBd,KAAKM,UAAUO,iBAAiB,QAAS,SAACL,GACtCH,EAAKM,OAAS,SACdF,QAAQO,KAAK,8BAQdb,EAAAc,UAAAC,cAAKhB,GAER,OADAF,KAAKY,YAAYO,KAAK,IAAItB,EAAU,EAAGK,IAChCF,MAOJG,EAAAc,UAAAG,iBAAQlB,GAEX,OADAF,KAAKY,YAAYO,KAAK,IAAItB,EAAU,EAAGK,IAChCF,MAMJG,EAAAc,UAAAI,oBACH,OAAOrB,MAMJG,EAAAc,UAAAK,sBACH,OAAOtB,MAOJG,EAAAc,UAAAM,cAAKH,GACR,IACIpB,KAAKM,UAAUiB,KAAKH,GACtB,MAAOZ,GACLC,QAAQC,MAAMF,GAElB,OAAOR,MAMJG,EAAAc,UAAAO,iBACHxB,KAAKM,UAAUkB,SAOZrB,EAAAc,UAAAH,uBAAcW,GACjB,IAAK,IAAIC,EAAI,EAAGC,EAAM3B,KAAKY,YAAYgB,OAAQF,EAAIC,EAAKD,IAAK,CACzD,IAAIG,EAAM7B,KAAKY,YAAYc,GAM3B,GAJiB,IAAbG,EAAI5B,OACJD,KAAK8B,aAAeD,EAAI3B,EAAEF,KAAK8B,aAAc9B,OAChC,IAATyB,IAAezB,KAAKY,YAAYc,GAAK,IAAI7B,EAAU,EAAG,gBAE7C,IAAbgC,EAAI5B,KAAY,CAChB,IAAa,IAATwB,EAAe,MASnBzB,KAAK8B,aAAeD,EAAI3B,EAAEF,KAAKe,aAAagB,KAAM/B,KAAK8B,aAAc9B,KAAMA,KAAKe,uCAMjFZ,EAAAc,UAAA,QAAK,gBACZ,OAAOjB,KAAKW,0CAxIpB,gBCME,SAAAqB,IACEhC,KAAKiC,QAAU,IAAIC,WAGdF,EAAAf,UAAAkB,cAAK/B,GACV,IAAKJ,KAAKoC,eAAehC,GAAM,CAC7B,IAAIiC,EAAS,IAAIlC,EAAOC,GAExB,OADAJ,KAAKiC,QAAQK,IAAIlC,EAAKiC,GACfA,IAIHL,EAAAf,UAAAmB,wBAAehC,GAQrB,OAPAJ,KAAKiC,QAAQM,QAAQ,SAACC,EAAKC,GACzB,GAAID,IAAQpC,EAGV,OADAK,QAAQO,KAAK,0CACN,KAGJ,uBA3BV0B,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,yJCPdC,EAAA,WAkBE,SAAAA,EAAoBC,GAAA9C,KAAA8C,iBAAAA,6BAdrBC,EAAAA,UAASJ,KAAA,CAAC,CACTK,SAAU,oBACVC,SAAU,wGAQVC,OAAQ,gDAbDlB,OADT,GCAAmB,EAAA,oDAGCC,EAAAA,SAAQT,KAAA,CAAC,CACRU,QAAS,GAETC,aAAc,CAACT,GACfU,QAAS,CAACV,SAPZ","sourcesContent":["export class Subscribe {\n    public type: number; //then: 0, message: 1, catch: 2, finally: 3.\n    public f: Function;\n    constructor(_type: number, _f: Function) {\n        this.type = _type;\n        this.f = _f;\n    }\n}","import { Observable, Subscription } from \"rxjs\";\nimport { Utils } from \"./utils\";\nimport { Subscribe } from \"./subscribe\";\n/**\n * Socket class\n * each socket handles a single WebScoket Connection.\n */\nexport class Socket {\n    private websocket: WebSocket;\n    private _state: string;\n    private _passingData: any;\n    private _receiveData: any;\n    private _openObservable: Observable<any>;\n    private _errorObservable: Observable<any>;\n    private _messageObservable: Observable<any>;\n    private _closeObservable: Observable<any>;\n    private _subscribes: Subscribe[];\n\n    constructor(private url: string) {\n        try {\n            this.websocket = new WebSocket(url);\n        } catch(e) {\n             console.error(e);\n        }\n        this._state = \"closed\";\n        this._subscribes = [];\n        //onOpen\n        this.websocket.addEventListener(\"open\", (e) => {\n            //websocket stream start\n            this.subscribeLoop(true);\n        })\n\n        //onError\n        this.websocket.addEventListener(\"error\", (e) => {\n            console.error(\"websocket onError\");\n        })\n\n        //onMessage\n        // this._messageObservable = Observable.create((observer) => {\n        //     this.websocket.addEventListener(\"message\", (e) => {\n        //         observer.next({\n        //             event: e\n        //         });\n        //         //stream start again\n        //         this.subscribeLoop(false);\n        //     });\n        // });\n\n        //onMessage\n        this.websocket.addEventListener(\"message\", (e) => {\n            this._receiveData = e;\n            //stream start again\n            this.subscribeLoop(false);\n        });\n\n        //onClose\n        this.websocket.addEventListener(\"close\", (e) => {\n            this._state = \"closed\";\n            console.warn(\"websocket onClose\");\n        });\n    }\n\n    /**\n     * reveive data from previous handler, wouldn't block current stream.\n     * @param f \n     */\n    public then(f: (d: any, socket?: Socket) => any): Socket {\n        this._subscribes.push(new Subscribe(0, f));\n        return this;\n    }\n\n    /**\n     * callback funtion when websocket reveive message. \n     * @param f \n     */\n    public message(f: (text: any, d?: any, socket?: Socket, event?: Event) => any): Socket {\n        this._subscribes.push(new Subscribe(1, f));\n        return this;\n    }\n\n    /**\n     * catch error or close state on websocket;\n     */\n    public catch(): Socket {\n        return this;\n    }\n\n    /**\n     * finally handler.\n     */\n    public finally(): Socket {\n        return this;\n    }\n\n    /**\n     * send message via this websocket\n     * @param message \n     */\n    public send(message: string): Socket {\n        try {\n            this.websocket.send(message);\n        } catch (e) {\n            console.error(e);\n        }\n        return this;\n    }\n\n    /**\n     * close websocket\n     */\n    public close(): void {\n        this.websocket.close();\n    }\n\n    /**\n     * traversal subscirbes set, execute action according to item's type\n     * @param init if subscribeLoop is the first tiem to execute, than every 'then' handler before the first message handler will be remove after execute.\n     */\n    public subscribeLoop(init: boolean): void {\n        for (let i = 0, len = this._subscribes.length; i < len; i++) {\n            let sub = this._subscribes[i];\n            \n            if (sub.type === 0) {\n                this._passingData = sub.f(this._passingData, this);\n                if (init === true) this._subscribes[i] = new Subscribe(0, () => {});\n            }\n            if (sub.type === 1) {\n                if (init === true) break;\n                // this._messageObservable.subscribe({\n                //     next(d) {\n                //         socket._passingData = sub.f((d.event.data), socket._passingData, socket, d.event);\n                //     },\n                //     error(msg) {\n                //         //call the catch handler\n                //     }\n                // });\n                this._passingData = sub.f(this._receiveData.data, this._passingData, this, this._receiveData);\n            }\n        }\n    }\n\n    //get state property\n    public get state() {\n        return this._state;\n    }\n\n\n\n}","import { Injectable } from '@angular/core';\nimport { Socket } from './socket';\n\n/**\n * this service provides multiple methods to create websocket, add callback function to websocekt or destory webscoket.\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class NgxWebsocketService {\n  //save all the socket opened by this service\n  private sockets: Map<string, Socket>;\n  \n  constructor() {\n    this.sockets = new Map<string, Socket>();\n  }\n\n  public open(url): Socket {\n    if (!this.checkExistence(url)) {\n      let socket = new Socket(url);\n      this.sockets.set(url, socket);\n      return socket;\n    }\n  }\n\n  private checkExistence(url) {\n    this.sockets.forEach((key, value) => {\n      if (key === url) {\n        //check connection state\n        console.warn(\"a websocket with same url has existed\");\n        return true;\n      }\n    })\n    return false;\n  }\n}\n","import { Component, OnInit } from '@angular/core';\nimport { NgxWebsocketService } from './ngx-websocket.service';\nimport { Socket } from './socket';\n\n@Component({\n  selector: 'enl-ngx-websocket',\n  template: `\n    <p>\n      ngx-websocket works!\n    </p>\n    <div>\n      <button>åé</button>\n    </div>\n  `,\n  styles: []\n})\nexport class NgxWebsocketComponent {\n  socket: Socket;\n  constructor(private websocketService: NgxWebsocketService,\n    ) {\n      \n     }\n\n\n\n\n}\n","import { NgModule } from '@angular/core';\nimport { NgxWebsocketComponent } from './ngx-websocket.component';\n\n@NgModule({\n  imports: [\n  ],\n  declarations: [NgxWebsocketComponent],\n  exports: [NgxWebsocketComponent]\n})\nexport class NgxWebsocketModule { }\n"]}