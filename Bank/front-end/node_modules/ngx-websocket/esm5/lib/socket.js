/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Subscribe } from "./subscribe";
/**
 * Socket class
 * each socket handles a single WebScoket Connection.
 */
var /**
 * Socket class
 * each socket handles a single WebScoket Connection.
 */
Socket = /** @class */ (function () {
    function Socket(url) {
        var _this = this;
        this.url = url;
        try {
            this.websocket = new WebSocket(url);
        }
        catch (/** @type {?} */ e) {
            console.error(e);
        }
        this._state = "closed";
        this._subscribes = [];
        //onOpen
        this.websocket.addEventListener("open", function (e) {
            //websocket stream start
            //websocket stream start
            _this.subscribeLoop(true);
        });
        //onError
        this.websocket.addEventListener("error", function (e) {
            console.error("websocket onError");
        });
        //onMessage
        // this._messageObservable = Observable.create((observer) => {
        //     this.websocket.addEventListener("message", (e) => {
        //         observer.next({
        //             event: e
        //         });
        //         //stream start again
        //         this.subscribeLoop(false);
        //     });
        // });
        //onMessage
        this.websocket.addEventListener("message", function (e) {
            _this._receiveData = e;
            //stream start again
            //stream start again
            _this.subscribeLoop(false);
        });
        //onClose
        this.websocket.addEventListener("close", function (e) {
            _this._state = "closed";
            console.warn("websocket onClose");
        });
    }
    /**
     * reveive data from previous handler, wouldn't block current stream.
     * @param {?} f
     * @return {?}
     */
    Socket.prototype.then = /**
     * reveive data from previous handler, wouldn't block current stream.
     * @param {?} f
     * @return {?}
     */
    function (f) {
        this._subscribes.push(new Subscribe(0, f));
        return this;
    };
    /**
     * callback funtion when websocket reveive message.
     * @param {?} f
     * @return {?}
     */
    Socket.prototype.message = /**
     * callback funtion when websocket reveive message.
     * @param {?} f
     * @return {?}
     */
    function (f) {
        this._subscribes.push(new Subscribe(1, f));
        return this;
    };
    /**
     * catch error or close state on websocket;
     * @return {?}
     */
    Socket.prototype.catch = /**
     * catch error or close state on websocket;
     * @return {?}
     */
    function () {
        return this;
    };
    /**
     * finally handler.
     * @return {?}
     */
    Socket.prototype.finally = /**
     * finally handler.
     * @return {?}
     */
    function () {
        return this;
    };
    /**
     * send message via this websocket
     * @param {?} message
     * @return {?}
     */
    Socket.prototype.send = /**
     * send message via this websocket
     * @param {?} message
     * @return {?}
     */
    function (message) {
        try {
            this.websocket.send(message);
        }
        catch (/** @type {?} */ e) {
            console.error(e);
        }
        return this;
    };
    /**
     * close websocket
     * @return {?}
     */
    Socket.prototype.close = /**
     * close websocket
     * @return {?}
     */
    function () {
        this.websocket.close();
    };
    /**
     * traversal subscirbes set, execute action according to item's type
     * @param {?} init if subscribeLoop is the first tiem to execute, than every 'then' handler before the first message handler will be remove after execute.
     * @return {?}
     */
    Socket.prototype.subscribeLoop = /**
     * traversal subscirbes set, execute action according to item's type
     * @param {?} init if subscribeLoop is the first tiem to execute, than every 'then' handler before the first message handler will be remove after execute.
     * @return {?}
     */
    function (init) {
        for (var /** @type {?} */ i = 0, /** @type {?} */ len = this._subscribes.length; i < len; i++) {
            var /** @type {?} */ sub = this._subscribes[i];
            if (sub.type === 0) {
                this._passingData = sub.f(this._passingData, this);
                if (init === true)
                    this._subscribes[i] = new Subscribe(0, function () { });
            }
            if (sub.type === 1) {
                if (init === true)
                    break;
                // this._messageObservable.subscribe({
                //     next(d) {
                //         socket._passingData = sub.f((d.event.data), socket._passingData, socket, d.event);
                //     },
                //     error(msg) {
                //         //call the catch handler
                //     }
                // });
                this._passingData = sub.f(this._receiveData.data, this._passingData, this, this._receiveData);
            }
        }
    };
    Object.defineProperty(Socket.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    return Socket;
}());
/**
 * Socket class
 * each socket handles a single WebScoket Connection.
 */
export { Socket };
function Socket_tsickle_Closure_declarations() {
    /** @type {?} */
    Socket.prototype.websocket;
    /** @type {?} */
    Socket.prototype._state;
    /** @type {?} */
    Socket.prototype._passingData;
    /** @type {?} */
    Socket.prototype._receiveData;
    /** @type {?} */
    Socket.prototype._openObservable;
    /** @type {?} */
    Socket.prototype._errorObservable;
    /** @type {?} */
    Socket.prototype._messageObservable;
    /** @type {?} */
    Socket.prototype._closeObservable;
    /** @type {?} */
    Socket.prototype._subscribes;
    /** @type {?} */
    Socket.prototype.url;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ja2V0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXdlYnNvY2tldC8iLCJzb3VyY2VzIjpbImxpYi9zb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7Ozs7O0FBS3hDOzs7O0FBQUE7SUFXSSxnQkFBb0IsR0FBVztRQUEvQixpQkEwQ0M7UUExQ21CLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDM0IsSUFBSSxDQUFDO1lBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2QztRQUFDLEtBQUssQ0FBQSxDQUFDLGlCQUFBLENBQUMsRUFBRSxDQUFDO1lBQ1AsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQjtRQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDOztRQUV0QixJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxVQUFDLENBQUM7O1lBRXRDLEFBREEsd0JBQXdCO1lBQ3hCLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUIsQ0FBQyxDQUFBOztRQUdGLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsQ0FBQztZQUN2QyxPQUFPLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEMsQ0FBQyxDQUFBOzs7Ozs7Ozs7Ozs7UUFjRixJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxVQUFDLENBQUM7WUFDekMsS0FBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7O1lBRXRCLEFBREEsb0JBQW9CO1lBQ3BCLEtBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDN0IsQ0FBQyxDQUFDOztRQUdILElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsQ0FBQztZQUN2QyxLQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztZQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDckMsQ0FBQyxDQUFDO0tBQ047Ozs7OztJQU1NLHFCQUFJOzs7OztjQUFDLENBQW1DO1FBQzNDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Ozs7Ozs7SUFPVCx3QkFBTzs7Ozs7Y0FBQyxDQUE4RDtRQUN6RSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDOzs7Ozs7SUFNVCxzQkFBSzs7Ozs7UUFDUixNQUFNLENBQUMsSUFBSSxDQUFDOzs7Ozs7SUFNVCx3QkFBTzs7Ozs7UUFDVixNQUFNLENBQUMsSUFBSSxDQUFDOzs7Ozs7O0lBT1QscUJBQUk7Ozs7O2NBQUMsT0FBZTtRQUN2QixJQUFJLENBQUM7WUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNoQztRQUFDLEtBQUssQ0FBQyxDQUFDLGlCQUFBLENBQUMsRUFBRSxDQUFDO1lBQ1QsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQjtRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUM7Ozs7OztJQU1ULHNCQUFLOzs7OztRQUNSLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7Ozs7SUFPcEIsOEJBQWE7Ozs7O2NBQUMsSUFBYTtRQUM5QixHQUFHLENBQUMsQ0FBQyxxQkFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzFELHFCQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTlCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakIsSUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ25ELEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM7b0JBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsZUFBUSxDQUFDLENBQUM7YUFDdkU7WUFDRCxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pCLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM7b0JBQUMsS0FBSyxDQUFDOzs7Ozs7Ozs7Z0JBU3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDakc7U0FDSjs7MEJBSU0seUJBQUs7Ozs7O1lBQ1osTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7Ozs7O2lCQS9JM0I7SUFvSkMsQ0FBQTs7Ozs7QUE3SUQsa0JBNklDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IFV0aWxzIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IFN1YnNjcmliZSB9IGZyb20gXCIuL3N1YnNjcmliZVwiO1xuLyoqXG4gKiBTb2NrZXQgY2xhc3NcbiAqIGVhY2ggc29ja2V0IGhhbmRsZXMgYSBzaW5nbGUgV2ViU2Nva2V0IENvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXQge1xuICAgIHByaXZhdGUgd2Vic29ja2V0OiBXZWJTb2NrZXQ7XG4gICAgcHJpdmF0ZSBfc3RhdGU6IHN0cmluZztcbiAgICBwcml2YXRlIF9wYXNzaW5nRGF0YTogYW55O1xuICAgIHByaXZhdGUgX3JlY2VpdmVEYXRhOiBhbnk7XG4gICAgcHJpdmF0ZSBfb3Blbk9ic2VydmFibGU6IE9ic2VydmFibGU8YW55PjtcbiAgICBwcml2YXRlIF9lcnJvck9ic2VydmFibGU6IE9ic2VydmFibGU8YW55PjtcbiAgICBwcml2YXRlIF9tZXNzYWdlT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByaXZhdGUgX2Nsb3NlT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByaXZhdGUgX3N1YnNjcmliZXM6IFN1YnNjcmliZVtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB1cmw6IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVzID0gW107XG4gICAgICAgIC8vb25PcGVuXG4gICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAvL3dlYnNvY2tldCBzdHJlYW0gc3RhcnRcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlTG9vcCh0cnVlKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvL29uRXJyb3JcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwid2Vic29ja2V0IG9uRXJyb3JcIik7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9vbk1lc3NhZ2VcbiAgICAgICAgLy8gdGhpcy5fbWVzc2FnZU9ic2VydmFibGUgPSBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgLy8gICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgIC8vICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgIC8vICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICAgICAgLy9zdHJlYW0gc3RhcnQgYWdhaW5cbiAgICAgICAgLy8gICAgICAgICB0aGlzLnN1YnNjcmliZUxvb3AoZmFsc2UpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0pO1xuXG4gICAgICAgIC8vb25NZXNzYWdlXG4gICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZWNlaXZlRGF0YSA9IGU7XG4gICAgICAgICAgICAvL3N0cmVhbSBzdGFydCBhZ2FpblxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVMb29wKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9vbkNsb3NlXG4gICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwid2Vic29ja2V0IG9uQ2xvc2VcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldmVpdmUgZGF0YSBmcm9tIHByZXZpb3VzIGhhbmRsZXIsIHdvdWxkbid0IGJsb2NrIGN1cnJlbnQgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBmIFxuICAgICAqL1xuICAgIHB1YmxpYyB0aGVuKGY6IChkOiBhbnksIHNvY2tldD86IFNvY2tldCkgPT4gYW55KTogU29ja2V0IHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcy5wdXNoKG5ldyBTdWJzY3JpYmUoMCwgZikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayBmdW50aW9uIHdoZW4gd2Vic29ja2V0IHJldmVpdmUgbWVzc2FnZS4gXG4gICAgICogQHBhcmFtIGYgXG4gICAgICovXG4gICAgcHVibGljIG1lc3NhZ2UoZjogKHRleHQ6IGFueSwgZD86IGFueSwgc29ja2V0PzogU29ja2V0LCBldmVudD86IEV2ZW50KSA9PiBhbnkpOiBTb2NrZXQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVzLnB1c2gobmV3IFN1YnNjcmliZSgxLCBmKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhdGNoIGVycm9yIG9yIGNsb3NlIHN0YXRlIG9uIHdlYnNvY2tldDtcbiAgICAgKi9cbiAgICBwdWJsaWMgY2F0Y2goKTogU29ja2V0IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluYWxseSBoYW5kbGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBmaW5hbGx5KCk6IFNvY2tldCB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbmQgbWVzc2FnZSB2aWEgdGhpcyB3ZWJzb2NrZXRcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2VuZChtZXNzYWdlOiBzdHJpbmcpOiBTb2NrZXQge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSB3ZWJzb2NrZXRcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhdmVyc2FsIHN1YnNjaXJiZXMgc2V0LCBleGVjdXRlIGFjdGlvbiBhY2NvcmRpbmcgdG8gaXRlbSdzIHR5cGVcbiAgICAgKiBAcGFyYW0gaW5pdCBpZiBzdWJzY3JpYmVMb29wIGlzIHRoZSBmaXJzdCB0aWVtIHRvIGV4ZWN1dGUsIHRoYW4gZXZlcnkgJ3RoZW4nIGhhbmRsZXIgYmVmb3JlIHRoZSBmaXJzdCBtZXNzYWdlIGhhbmRsZXIgd2lsbCBiZSByZW1vdmUgYWZ0ZXIgZXhlY3V0ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3Vic2NyaWJlTG9vcChpbml0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9zdWJzY3JpYmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3ViID0gdGhpcy5fc3Vic2NyaWJlc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHN1Yi50eXBlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzc2luZ0RhdGEgPSBzdWIuZih0aGlzLl9wYXNzaW5nRGF0YSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgPT09IHRydWUpIHRoaXMuX3N1YnNjcmliZXNbaV0gPSBuZXcgU3Vic2NyaWJlKDAsICgpID0+IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWIudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0ID09PSB0cnVlKSBicmVhaztcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9tZXNzYWdlT2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICBuZXh0KGQpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHNvY2tldC5fcGFzc2luZ0RhdGEgPSBzdWIuZigoZC5ldmVudC5kYXRhKSwgc29ja2V0Ll9wYXNzaW5nRGF0YSwgc29ja2V0LCBkLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyAgICAgZXJyb3IobXNnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAvL2NhbGwgdGhlIGNhdGNoIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bhc3NpbmdEYXRhID0gc3ViLmYodGhpcy5fcmVjZWl2ZURhdGEuZGF0YSwgdGhpcy5fcGFzc2luZ0RhdGEsIHRoaXMsIHRoaXMuX3JlY2VpdmVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZ2V0IHN0YXRlIHByb3BlcnR5XG4gICAgcHVibGljIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cblxuXG5cbn0iXX0=