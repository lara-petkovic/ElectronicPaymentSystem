/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Subscribe } from "./subscribe";
/**
 * Socket class
 * each socket handles a single WebScoket Connection.
 */
export class Socket {
    /**
     * @param {?} url
     */
    constructor(url) {
        this.url = url;
        try {
            this.websocket = new WebSocket(url);
        }
        catch (/** @type {?} */ e) {
            console.error(e);
        }
        this._state = "closed";
        this._subscribes = [];
        //onOpen
        this.websocket.addEventListener("open", (e) => {
            //websocket stream start
            this.subscribeLoop(true);
        });
        //onError
        this.websocket.addEventListener("error", (e) => {
            console.error("websocket onError");
        });
        //onMessage
        // this._messageObservable = Observable.create((observer) => {
        //     this.websocket.addEventListener("message", (e) => {
        //         observer.next({
        //             event: e
        //         });
        //         //stream start again
        //         this.subscribeLoop(false);
        //     });
        // });
        //onMessage
        this.websocket.addEventListener("message", (e) => {
            this._receiveData = e;
            //stream start again
            this.subscribeLoop(false);
        });
        //onClose
        this.websocket.addEventListener("close", (e) => {
            this._state = "closed";
            console.warn("websocket onClose");
        });
    }
    /**
     * reveive data from previous handler, wouldn't block current stream.
     * @param {?} f
     * @return {?}
     */
    then(f) {
        this._subscribes.push(new Subscribe(0, f));
        return this;
    }
    /**
     * callback funtion when websocket reveive message.
     * @param {?} f
     * @return {?}
     */
    message(f) {
        this._subscribes.push(new Subscribe(1, f));
        return this;
    }
    /**
     * catch error or close state on websocket;
     * @return {?}
     */
    catch() {
        return this;
    }
    /**
     * finally handler.
     * @return {?}
     */
    finally() {
        return this;
    }
    /**
     * send message via this websocket
     * @param {?} message
     * @return {?}
     */
    send(message) {
        try {
            this.websocket.send(message);
        }
        catch (/** @type {?} */ e) {
            console.error(e);
        }
        return this;
    }
    /**
     * close websocket
     * @return {?}
     */
    close() {
        this.websocket.close();
    }
    /**
     * traversal subscirbes set, execute action according to item's type
     * @param {?} init if subscribeLoop is the first tiem to execute, than every 'then' handler before the first message handler will be remove after execute.
     * @return {?}
     */
    subscribeLoop(init) {
        for (let /** @type {?} */ i = 0, /** @type {?} */ len = this._subscribes.length; i < len; i++) {
            let /** @type {?} */ sub = this._subscribes[i];
            if (sub.type === 0) {
                this._passingData = sub.f(this._passingData, this);
                if (init === true)
                    this._subscribes[i] = new Subscribe(0, () => { });
            }
            if (sub.type === 1) {
                if (init === true)
                    break;
                // this._messageObservable.subscribe({
                //     next(d) {
                //         socket._passingData = sub.f((d.event.data), socket._passingData, socket, d.event);
                //     },
                //     error(msg) {
                //         //call the catch handler
                //     }
                // });
                this._passingData = sub.f(this._receiveData.data, this._passingData, this, this._receiveData);
            }
        }
    }
    /**
     * @return {?}
     */
    get state() {
        return this._state;
    }
}
function Socket_tsickle_Closure_declarations() {
    /** @type {?} */
    Socket.prototype.websocket;
    /** @type {?} */
    Socket.prototype._state;
    /** @type {?} */
    Socket.prototype._passingData;
    /** @type {?} */
    Socket.prototype._receiveData;
    /** @type {?} */
    Socket.prototype._openObservable;
    /** @type {?} */
    Socket.prototype._errorObservable;
    /** @type {?} */
    Socket.prototype._messageObservable;
    /** @type {?} */
    Socket.prototype._closeObservable;
    /** @type {?} */
    Socket.prototype._subscribes;
    /** @type {?} */
    Socket.prototype.url;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ja2V0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXdlYnNvY2tldC8iLCJzb3VyY2VzIjpbImxpYi9zb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7Ozs7O0FBS3hDLE1BQU07Ozs7SUFXRixZQUFvQixHQUFXO1FBQVgsUUFBRyxHQUFILEdBQUcsQ0FBUTtRQUMzQixJQUFJLENBQUM7WUFDRCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3ZDO1FBQUMsS0FBSyxDQUFBLENBQUMsaUJBQUEsQ0FBQyxFQUFFLENBQUM7WUFDUCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JCO1FBQ0QsSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUM7UUFDdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7O1FBRXRCLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7O1lBRTFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUIsQ0FBQyxDQUFBOztRQUdGLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDM0MsT0FBTyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDLENBQUMsQ0FBQTs7Ozs7Ozs7Ozs7O1FBY0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUM3QyxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQzs7WUFFdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM3QixDQUFDLENBQUM7O1FBR0gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMzQyxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztZQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDckMsQ0FBQyxDQUFDO0tBQ047Ozs7OztJQU1NLElBQUksQ0FBQyxDQUFtQztRQUMzQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDOzs7Ozs7O0lBT1QsT0FBTyxDQUFDLENBQThEO1FBQ3pFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Ozs7OztJQU1ULEtBQUs7UUFDUixNQUFNLENBQUMsSUFBSSxDQUFDOzs7Ozs7SUFNVCxPQUFPO1FBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQzs7Ozs7OztJQU9ULElBQUksQ0FBQyxPQUFlO1FBQ3ZCLElBQUksQ0FBQztZQUNELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2hDO1FBQUMsS0FBSyxDQUFDLENBQUMsaUJBQUEsQ0FBQyxFQUFFLENBQUM7WUFDVCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3BCO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQzs7Ozs7O0lBTVQsS0FBSztRQUNSLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7Ozs7SUFPcEIsYUFBYSxDQUFDLElBQWE7UUFDOUIsR0FBRyxDQUFDLENBQUMscUJBQUksQ0FBQyxHQUFHLENBQUMsbUJBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMxRCxxQkFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUU5QixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pCLElBQUksQ0FBQyxZQUFZLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNuRCxFQUFFLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO29CQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFHLENBQUMsQ0FBQzthQUN2RTtZQUNELEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakIsRUFBRSxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztvQkFBQyxLQUFLLENBQUM7Ozs7Ozs7OztnQkFTekIsSUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUNqRztTQUNKOzs7OztRQUlNLEtBQUs7UUFDWixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7Q0FLMUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJlIH0gZnJvbSBcIi4vc3Vic2NyaWJlXCI7XG4vKipcbiAqIFNvY2tldCBjbGFzc1xuICogZWFjaCBzb2NrZXQgaGFuZGxlcyBhIHNpbmdsZSBXZWJTY29rZXQgQ29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldCB7XG4gICAgcHJpdmF0ZSB3ZWJzb2NrZXQ6IFdlYlNvY2tldDtcbiAgICBwcml2YXRlIF9zdGF0ZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX3Bhc3NpbmdEYXRhOiBhbnk7XG4gICAgcHJpdmF0ZSBfcmVjZWl2ZURhdGE6IGFueTtcbiAgICBwcml2YXRlIF9vcGVuT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByaXZhdGUgX2Vycm9yT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+O1xuICAgIHByaXZhdGUgX21lc3NhZ2VPYnNlcnZhYmxlOiBPYnNlcnZhYmxlPGFueT47XG4gICAgcHJpdmF0ZSBfY2xvc2VPYnNlcnZhYmxlOiBPYnNlcnZhYmxlPGFueT47XG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlczogU3Vic2NyaWJlW107XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHVybDogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgLy9vbk9wZW5cbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIC8vd2Vic29ja2V0IHN0cmVhbSBzdGFydFxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVMb29wKHRydWUpO1xuICAgICAgICB9KVxuXG4gICAgICAgIC8vb25FcnJvclxuICAgICAgICB0aGlzLndlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ3ZWJzb2NrZXQgb25FcnJvclwiKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvL29uTWVzc2FnZVxuICAgICAgICAvLyB0aGlzLl9tZXNzYWdlT2JzZXJ2YWJsZSA9IE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgLy8gICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgICAgICAvL3N0cmVhbSBzdGFydCBhZ2FpblxuICAgICAgICAvLyAgICAgICAgIHRoaXMuc3Vic2NyaWJlTG9vcChmYWxzZSk7XG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgLy9vbk1lc3NhZ2VcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVEYXRhID0gZTtcbiAgICAgICAgICAgIC8vc3RyZWFtIHN0YXJ0IGFnYWluXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZUxvb3AoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL29uQ2xvc2VcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ3ZWJzb2NrZXQgb25DbG9zZVwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV2ZWl2ZSBkYXRhIGZyb20gcHJldmlvdXMgaGFuZGxlciwgd291bGRuJ3QgYmxvY2sgY3VycmVudCBzdHJlYW0uXG4gICAgICogQHBhcmFtIGYgXG4gICAgICovXG4gICAgcHVibGljIHRoZW4oZjogKGQ6IGFueSwgc29ja2V0PzogU29ja2V0KSA9PiBhbnkpOiBTb2NrZXQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVzLnB1c2gobmV3IFN1YnNjcmliZSgwLCBmKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGxiYWNrIGZ1bnRpb24gd2hlbiB3ZWJzb2NrZXQgcmV2ZWl2ZSBtZXNzYWdlLiBcbiAgICAgKiBAcGFyYW0gZiBcbiAgICAgKi9cbiAgICBwdWJsaWMgbWVzc2FnZShmOiAodGV4dDogYW55LCBkPzogYW55LCBzb2NrZXQ/OiBTb2NrZXQsIGV2ZW50PzogRXZlbnQpID0+IGFueSk6IFNvY2tldCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXMucHVzaChuZXcgU3Vic2NyaWJlKDEsIGYpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2F0Y2ggZXJyb3Igb3IgY2xvc2Ugc3RhdGUgb24gd2Vic29ja2V0O1xuICAgICAqL1xuICAgIHB1YmxpYyBjYXRjaCgpOiBTb2NrZXQge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5hbGx5IGhhbmRsZXIuXG4gICAgICovXG4gICAgcHVibGljIGZpbmFsbHkoKTogU29ja2V0IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VuZCBtZXNzYWdlIHZpYSB0aGlzIHdlYnNvY2tldFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZW5kKG1lc3NhZ2U6IHN0cmluZyk6IFNvY2tldCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsb3NlIHdlYnNvY2tldFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmF2ZXJzYWwgc3Vic2NpcmJlcyBzZXQsIGV4ZWN1dGUgYWN0aW9uIGFjY29yZGluZyB0byBpdGVtJ3MgdHlwZVxuICAgICAqIEBwYXJhbSBpbml0IGlmIHN1YnNjcmliZUxvb3AgaXMgdGhlIGZpcnN0IHRpZW0gdG8gZXhlY3V0ZSwgdGhhbiBldmVyeSAndGhlbicgaGFuZGxlciBiZWZvcmUgdGhlIGZpcnN0IG1lc3NhZ2UgaGFuZGxlciB3aWxsIGJlIHJlbW92ZSBhZnRlciBleGVjdXRlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdWJzY3JpYmVMb29wKGluaXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3N1YnNjcmliZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdWIgPSB0aGlzLl9zdWJzY3JpYmVzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc3ViLnR5cGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXNzaW5nRGF0YSA9IHN1Yi5mKHRoaXMuX3Bhc3NpbmdEYXRhLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdCA9PT0gdHJ1ZSkgdGhpcy5fc3Vic2NyaWJlc1tpXSA9IG5ldyBTdWJzY3JpYmUoMCwgKCkgPT4ge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1Yi50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX21lc3NhZ2VPYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgLy8gICAgIG5leHQoZCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgc29ja2V0Ll9wYXNzaW5nRGF0YSA9IHN1Yi5mKChkLmV2ZW50LmRhdGEpLCBzb2NrZXQuX3Bhc3NpbmdEYXRhLCBzb2NrZXQsIGQuZXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vICAgICB9LFxuICAgICAgICAgICAgICAgIC8vICAgICBlcnJvcihtc2cpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIC8vY2FsbCB0aGUgY2F0Y2ggaGFuZGxlclxuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzc2luZ0RhdGEgPSBzdWIuZih0aGlzLl9yZWNlaXZlRGF0YS5kYXRhLCB0aGlzLl9wYXNzaW5nRGF0YSwgdGhpcywgdGhpcy5fcmVjZWl2ZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9nZXQgc3RhdGUgcHJvcGVydHlcbiAgICBwdWJsaWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG5cblxufSJdfQ==